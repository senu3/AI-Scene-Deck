import { useDroppable, useDndContext } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';
import { Plus, MoreHorizontal, Edit2, Trash2 } from 'lucide-react';
import { useState, useRef, useEffect } from 'react';
import { useStore } from '../store/useStore';
import { useHistoryStore } from '../store/historyStore';
import { AddSceneCommand, RemoveSceneCommand, RenameSceneCommand } from '../store/commands';
import CutCard from './CutCard';
import CutGroupCard, { ExpandedGroupContainer } from './CutGroupCard';
import type { Asset, CutGroup, Cut } from '../types';
import { useStorylineDragController, type PlaceholderState } from '../hooks/useStorylineDragController';
import './Storyline.css';

// Scene color palette - cycles through for each scene
const SCENE_COLORS = [
  'var(--accent-secondary)',  // blue
  'var(--accent-purple)',     // purple
  'var(--accent-pink)',       // pink
  'var(--accent-success)',    // green
  'var(--accent-audio)',      // audio purple
];

const getSceneColor = (index: number) => SCENE_COLORS[index % SCENE_COLORS.length];

interface StorylineProps {
  activeId: string | null;
  activeType: 'cut' | 'scene' | null;
}

export default function Storyline({ activeId }: StorylineProps) {
  const { scenes, selectedSceneId, selectScene, vaultPath, createCutFromImport, closeDetailsPanel } = useStore();
  const { executeCommand } = useHistoryStore();
  const storylineRef = useRef<HTMLDivElement>(null);
  // --- DND: dnd-kit (reorder) ---
  const { active, over } = useDndContext();

  const handleBackgroundClick = (e: React.MouseEvent) => {
    const target = e.target as HTMLElement;
    if (target.closest('.cut-card')) return;
    if (target.closest('.scene-header')) return;
    if (target.closest('.scene-menu')) return;
    if (target.closest('.scene-menu-btn')) return;
    if (target.closest('.scene-name-input')) return;
    if (target.closest('.add-scene-btn')) return;
    selectScene(null);
  };

  const {
    placeholder,
    sourceSceneId,
    isOverDifferentScene,
    handleStorylineDragEnter,
    handleStorylineDragOver,
    handleStorylineDragLeave,
    handleInboundDrop,
  } = useStorylineDragController({
    scenes,
    active,
    over,
    vaultPath,
    createCutFromImport,
    closeDetailsPanel,
    executeCommand,
  });

  useEffect(() => {
    if (!selectedSceneId || !storylineRef.current) return;
    const sceneElement = storylineRef.current.querySelector(
      `[data-scene-id="${selectedSceneId}"]`
    );
    if (sceneElement) {
      sceneElement.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    }
  }, [selectedSceneId]);

  return (
    <div
      ref={storylineRef}
      className="storyline"
      onClick={handleBackgroundClick}
      onDragEnter={handleStorylineDragEnter}
      onDragOver={handleStorylineDragOver}
      onDragLeave={handleStorylineDragLeave}
      onDrop={handleInboundDrop}
    >
      <div className="storyline-content">
        {scenes.map((scene, index) => (
          <SceneColumn
            key={scene.id}
            sceneId={scene.id}
            sceneName={scene.name}
            sceneIndex={index}
            cuts={scene.cuts}
            groups={scene.groups || []}
            isSelected={selectedSceneId === scene.id}
            onSelect={() => selectScene(scene.id)}
            activeId={activeId}
            placeholder={placeholder?.sceneId === scene.id ? placeholder : null}
            sourceSceneId={sourceSceneId}
            isOverDifferentScene={!!isOverDifferentScene}
          />
        ))}

        <button className="add-scene-btn" onClick={() => {
          const sceneName = `Scene ${scenes.length + 1}`;
          executeCommand(new AddSceneCommand(sceneName)).catch((error) => {
            console.error('Failed to add scene:', error);
          });
        }}>
          <Plus size={24} />
          <span>Add Scene</span>
        </button>
      </div>
    </div>
  );
}

interface SceneColumnProps {
  sceneId: string;
  sceneName: string;
  sceneIndex: number;
  cuts: Array<{
    id: string;
    assetId: string;
    asset?: Asset;
    displayTime: number;
    order: number;
    isLipSync?: boolean;
    lipSyncFrameCount?: number;
  }>;
  groups: CutGroup[];
  isSelected: boolean;
  onSelect: () => void;
  activeId: string | null;
  placeholder: PlaceholderState | null;
  sourceSceneId?: string;
  isOverDifferentScene?: boolean;
}

function SceneColumn({
  sceneId,
  sceneName,
  sceneIndex,
  cuts,
  groups,
  isSelected,
  onSelect,
  activeId,
  placeholder,
  sourceSceneId,
  isOverDifferentScene,
}: SceneColumnProps) {
  const sceneColor = getSceneColor(sceneIndex);
  const { scenes, selectedGroupId, selectGroup, toggleGroupCollapsed } = useStore();
  const { executeCommand } = useHistoryStore();
  const [showMenu, setShowMenu] = useState(false);
  const [isEditing, setIsEditing] = useState(false);
  const [editName, setEditName] = useState(sceneName);
  const inputRef = useRef<HTMLInputElement>(null);
  const menuRef = useRef<HTMLDivElement>(null);
  const cutsContainerRef = useRef<HTMLDivElement>(null);

  // Droppable for cuts
  const { setNodeRef: setDroppableRef } = useDroppable({
    id: `dropzone-${sceneId}`,
    data: {
      sceneId,
      type: 'dropzone',
      index: cuts.length,
    },
  });

  // Check if this is the source scene and a cut is being dragged to a different scene
  const isSourceScene = sourceSceneId === sceneId;
  const shouldHideDraggedCard = isSourceScene && isOverDifferentScene;

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        setShowMenu(false);
      }
    };

    if (showMenu) {
      document.addEventListener('mousedown', handleClickOutside);
    }
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [showMenu]);

  const handleRename = () => {
    if (editName.trim() && editName !== sceneName) {
      executeCommand(new RenameSceneCommand(sceneId, editName.trim())).catch((error) => {
        console.error('Failed to rename scene:', error);
      });
    } else {
      setEditName(sceneName);
    }
    setIsEditing(false);
  };

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleRename();
    } else if (e.key === 'Escape') {
      setEditName(sceneName);
      setIsEditing(false);
    }
  };

  const handleDelete = () => {
    if (scenes.length > 1 && confirm(`Delete "${sceneName}"? All cuts will be removed.`)) {
      executeCommand(new RemoveSceneCommand(sceneId)).catch((error) => {
        console.error('Failed to remove scene:', error);
      });
    }
    setShowMenu(false);
  };


  // Helper to find which group a cut belongs to
  const findGroupForCut = (cutId: string): CutGroup | undefined => {
    return groups.find(g => g.cutIds.includes(cutId));
  };

  // Build the list of items including placeholder and groups
  const renderItems = () => {
    const items: React.ReactNode[] = [];
    const renderedGroups = new Set<string>();

    const placeholderElement = placeholder ? (
      <div key="placeholder" className="cut-card placeholder-card">
        <div className="placeholder-content">
          <Plus size={20} />
        </div>
      </div>
    ) : null;

    for (let i = 0; i < cuts.length; i++) {
      const cut = cuts[i];
      // Insert placeholder before this cut if needed
      if (placeholder && placeholder.insertIndex === i) {
        items.push(placeholderElement);
      }

      // Check if this cut belongs to a group
      const group = findGroupForCut(cut.id);

      if (group && !renderedGroups.has(group.id)) {
        // This is the first cut of a group we haven't rendered yet
        renderedGroups.add(group.id);

        // Get all cuts in this group (in group order)
        const groupCuts = group.cutIds
          .map(id => cuts.find(c => c.id === id))
          .filter((c): c is Cut => c !== undefined);

        if (group.isCollapsed) {
          // Render collapsed group card
          items.push(
            <CutGroupCard
              key={`group-${group.id}`}
              group={group}
              cuts={groupCuts}
              sceneId={sceneId}
              index={i}
              isDragging={activeId === `group-${group.id}`}
            />
          );
        } else {
          // Render expanded group container
          items.push(
            <ExpandedGroupContainer
              key={`group-${group.id}`}
              group={group}
              sceneId={sceneId}
              isSelected={selectedGroupId === group.id}
              onSelect={() => selectGroup(group.id)}
              onToggleCollapse={() => toggleGroupCollapsed(sceneId, group.id)}
            >
              {groupCuts.map((groupCut) => {
                const isHidden = shouldHideDraggedCard && activeId === groupCut.id;
                return (
                  <CutCard
                    key={groupCut.id}
                    cut={groupCut}
                    sceneId={sceneId}
                    index={cuts.findIndex(c => c.id === groupCut.id)}
                    isDragging={activeId === groupCut.id}
                    isHidden={isHidden}
                  />
                );
              })}
            </ExpandedGroupContainer>
          );
        }
      } else if (!group) {
        // Regular cut not in any group
        const isHidden = shouldHideDraggedCard && activeId === cut.id;

        items.push(
          <CutCard
            key={cut.id}
            cut={cut}
            sceneId={sceneId}
            index={i}
            isDragging={activeId === cut.id}
            isHidden={isHidden}
          />
        );
      }
      // If cut is in a group that was already rendered, skip it
    }

    // Add placeholder at the end if needed
    if (placeholder && placeholder.insertIndex >= cuts.length) {
      items.push(placeholderElement);
    }

    // === DEMO: Add lip sync cut card at the end of first scene ===
    if (sceneId === scenes[0]?.id) {
      items.push(
        <CutCard
          key="demo-lipsync"
          cut={{
            id: 'demo-lipsync-1',
            assetId: 'demo-asset',
            displayTime: 3.0,
            order: cuts.length,
            isLipSync: true,
            lipSyncFrameCount: 4,
          }}
          sceneId={sceneId}
          index={cuts.length}
          isDragging={false}
        />
      );
    }
    // === END DEMO ===

    return items;
  };

  // Combine refs for the cuts container
  const setCombinedRef = (node: HTMLDivElement | null) => {
    setDroppableRef(node);
    (cutsContainerRef as React.MutableRefObject<HTMLDivElement | null>).current = node;
  };

  const buildSortableItems = () => {
    const items: string[] = [];
    const renderedGroups = new Set<string>();

    for (let i = 0; i < cuts.length; i++) {
      const cut = cuts[i];
      const group = findGroupForCut(cut.id);

      if (group && !renderedGroups.has(group.id)) {
        renderedGroups.add(group.id);

        if (group.isCollapsed) {
          items.push(`group-${group.id}`);
        } else {
          const groupCuts = group.cutIds
            .map(id => cuts.find(c => c.id === id))
            .filter((c): c is Cut => c !== undefined);
          items.push(...groupCuts.map(c => c.id));
        }
      } else if (!group) {
        items.push(cut.id);
      }
    }

    return items;
  };

  const sortableItems = buildSortableItems();

  return (
    <div
      className={`scene-column ${isSelected ? 'selected' : ''}`}
      data-scene-id={sceneId}
      style={{ '--scene-color': sceneColor } as React.CSSProperties}
    >
      <div
        className="scene-header"
        onClick={(e) => {
          e.stopPropagation();
          onSelect();
        }}
      >
        <div className="scene-indicator" />

        {isEditing ? (
          <input
            ref={inputRef}
            type="text"
            className="scene-name-input"
            value={editName}
            onChange={(e) => setEditName(e.target.value)}
            onBlur={handleRename}
            onKeyDown={handleKeyDown}
            onClick={(e) => e.stopPropagation()}
          />
        ) : (
          <span className="scene-name">{sceneName.toUpperCase()}</span>
        )}

        <div className="scene-menu-container" ref={menuRef}>
          <button
            className="scene-menu-btn"
            onClick={(e) => {
              e.stopPropagation();
              setShowMenu(!showMenu);
            }}
          >
            <MoreHorizontal size={16} />
          </button>

          {showMenu && (
            <div className="scene-menu">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  setIsEditing(true);
                  setShowMenu(false);
                }}
              >
                <Edit2 size={14} />
                Rename
              </button>
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete();
                }}
                className="danger"
                disabled={scenes.length <= 1}
              >
                <Trash2 size={14} />
                Delete
              </button>
            </div>
          )}
        </div>
      </div>

      <SortableContext
        items={sortableItems}
        strategy={verticalListSortingStrategy}
      >
        <div
          ref={setCombinedRef}
          className={`scene-cuts ${placeholder ? 'has-placeholder' : ''}`}
        >
          {renderItems()}
        </div>
      </SortableContext>
    </div>
  );
}
