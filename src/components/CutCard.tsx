import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { useState, useEffect, useRef } from 'react';
import { Film, Image, Clock, Copy, Trash2, ArrowRightLeft, Clipboard, Scissors, Download, Loader2, Mic, Music, Layers, FolderMinus, RotateCcw } from 'lucide-react';
import { useStore } from '../store/useStore';
import type { Asset, Scene } from '../types';
import { v4 as uuidv4 } from 'uuid';
import './CutCard.css';
import { getThumbnail } from '../utils/thumbnailCache';

interface CutCardProps {
  cut: {
    id: string;
    assetId: string;
    asset?: Asset;
    displayTime: number;
    order: number;
    // Video clip fields
    inPoint?: number;
    outPoint?: number;
    isClip?: boolean;
    // Loading state
    isLoading?: boolean;
    loadingName?: string;
    // Lip sync fields
    isLipSync?: boolean;
    lipSyncFrameCount?: number;
  };
  sceneId: string;
  index: number;
  isDragging: boolean;
  isHidden?: boolean;
}

interface ContextMenuProps {
  x: number;
  y: number;
  isMultiSelect: boolean;
  selectedCount: number;
  scenes: Scene[];
  currentSceneId: string;
  canPaste: boolean;
  isClip: boolean;
  isInGroup: boolean;
  onClose: () => void;
  onCopy: () => void;
  onPaste: () => void;
  onDelete: () => void;
  onMoveToScene: (sceneId: string) => void;
  onFinalizeClip?: () => void;
  onReverseClip?: () => void;
  onCreateGroup?: () => void;
  onRemoveFromGroup?: () => void;
}

export function CutContextMenu({
  x,
  y,
  isMultiSelect,
  selectedCount,
  scenes,
  currentSceneId,
  canPaste,
  isClip,
  isInGroup,
  onClose,
  onCopy,
  onPaste,
  onDelete,
  onMoveToScene,
  onFinalizeClip,
  onReverseClip,
  onCreateGroup,
  onRemoveFromGroup,
}: ContextMenuProps) {
  const menuRef = useRef<HTMLDivElement>(null);
  const [showMoveSubmenu, setShowMoveSubmenu] = useState(false);

  useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        onClose();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [onClose]);

  // Filter out current scene from move options
  const otherScenes = scenes.filter(s => s.id !== currentSceneId);

  return (
    <div
      ref={menuRef}
      className="cut-context-menu"
      style={{ left: x, top: y }}
    >
      <div className="context-menu-header">
        {isMultiSelect ? `${selectedCount} cuts selected` : 'Cut options'}
      </div>

      <button onClick={onCopy}>
        <Copy size={14} />
        Copy{isMultiSelect ? ` (${selectedCount})` : ''}
      </button>

      {canPaste && (
        <button onClick={onPaste}>
          <Clipboard size={14} />
          Paste
        </button>
      )}

      {otherScenes.length > 0 && (
        <div
          className="context-menu-item-with-submenu"
          onMouseEnter={() => setShowMoveSubmenu(true)}
          onMouseLeave={() => setShowMoveSubmenu(false)}
        >
          <button>
            <ArrowRightLeft size={14} />
            Move to Scene
            <span className="submenu-arrow">â–¶</span>
          </button>

          {showMoveSubmenu && (
            <div className="context-submenu">
              {otherScenes.map(scene => (
                <button
                  key={scene.id}
                  onClick={() => onMoveToScene(scene.id)}
                >
                  {scene.name}
                </button>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Finalize Clip option - only for clips */}
      {isClip && !isMultiSelect && onFinalizeClip && (
        <>
          <div className="context-menu-divider" />
          <button onClick={onFinalizeClip} className="finalize">
            <Download size={14} />
            Finalize Clip (Add Cut)
          </button>
        </>
      )}

      {isClip && !isMultiSelect && onReverseClip && (
        <button onClick={onReverseClip} className="finalize">
          <RotateCcw size={14} />
          Reverse Clip (Add Cut)
        </button>
      )}

      {/* Group options */}
      <div className="context-menu-divider" />

      {/* Create Group - only for multi-select */}
      {isMultiSelect && onCreateGroup && (
        <button onClick={onCreateGroup}>
          <Layers size={14} />
          Create Group ({selectedCount})
        </button>
      )}

      {/* Remove from Group - only for grouped cuts */}
      {isInGroup && onRemoveFromGroup && (
        <button onClick={onRemoveFromGroup}>
          <FolderMinus size={14} />
          Remove from Group
        </button>
      )}

      <div className="context-menu-divider" />

      <button onClick={onDelete} className="danger">
        <Trash2 size={14} />
        Delete{isMultiSelect ? ` (${selectedCount})` : ''}
      </button>
    </div>
  );
}

export default function CutCard({ cut, sceneId, index, isDragging, isHidden }: CutCardProps) {
  const {
    selectedCutId,
    selectedCutIds,
    selectCut,
    toggleCutSelection,
    selectCutRange,
    getAsset,
    scenes,
    getSelectedCutIds,
    getSelectedCuts,
    moveCutsToScene,
    removeCut,
    copySelectedCuts,
    canPaste,
    pasteCuts,
    vaultPath,
    openVideoPreview,
    metadataStore,
    getCutGroup,
    createGroup,
    removeCutFromGroup,
    createCutFromImport,
    updateGroupCutOrder,
  } = useStore();
  const [thumbnail, setThumbnail] = useState<string | null>(null);
  const [contextMenu, setContextMenu] = useState<{ x: number; y: number } | null>(null);
  const [showLoadingSpinner, setShowLoadingSpinner] = useState(false);
  const loadingTimerRef = useRef<NodeJS.Timeout | null>(null);

  // Show spinner after 1 second of loading
  useEffect(() => {
    if (cut.isLoading) {
      loadingTimerRef.current = setTimeout(() => {
        setShowLoadingSpinner(true);
      }, 1000);
    } else {
      setShowLoadingSpinner(false);
      if (loadingTimerRef.current) {
        clearTimeout(loadingTimerRef.current);
        loadingTimerRef.current = null;
      }
    }

    return () => {
      if (loadingTimerRef.current) {
        clearTimeout(loadingTimerRef.current);
      }
    };
  }, [cut.isLoading]);

  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
  } = useSortable({
    id: cut.id,
    data: {
      type: 'cut',
      sceneId,
      index,
    },
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    display: isHidden ? 'none' : undefined,
  };

  const asset = cut.asset || getAsset(cut.assetId);
  const isSelected = selectedCutIds.has(cut.id) || selectedCutId === cut.id;
  const isMultiSelected = selectedCutIds.size > 1 && selectedCutIds.has(cut.id);
  const isVideo = asset?.type === 'video';
  const isLipSync = cut.isLipSync;
  const hasAttachedAudio = asset?.id && metadataStore?.metadata[asset.id]?.attachedAudioId;

  // Check if this cut is in a group
  const cutGroup = getCutGroup(sceneId, cut.id);
  const isInGroup = !!cutGroup;

  useEffect(() => {
    const loadThumbnail = async () => {
      if (asset?.thumbnail) {
        setThumbnail(asset.thumbnail);
        return;
      }

      if (asset?.path && (asset.type === 'image' || asset.type === 'video')) {
        try {
          const thumbnail = await getThumbnail(asset.path, asset.type);
          if (thumbnail) {
            setThumbnail(thumbnail);
          }
        } catch {
          // Failed to load thumbnail
        }
      }
    };

    loadThumbnail();
  }, [asset]);

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();

    // Ctrl/Cmd + click: toggle selection
    if (e.ctrlKey || e.metaKey) {
      toggleCutSelection(cut.id);
      return;
    }

    // Shift + click: range selection
    if (e.shiftKey) {
      selectCutRange(cut.id);
      return;
    }

    // Normal click: single selection
    selectCut(cut.id);
  };

  const handleDoubleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    // Open Single Mode preview for both video and image assets
    if (asset) {
      openVideoPreview(cut.id);
    }
  };

  const getBadgeColor = () => {
    // Generate a consistent color based on asset type
    if (isVideo) return 'var(--accent-video)';
    return 'var(--accent-primary)';
  };

  const handleContextMenu = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    // If right-clicking on a non-selected card, select it first
    if (!selectedCutIds.has(cut.id)) {
      selectCut(cut.id);
    }

    setContextMenu({ x: e.clientX, y: e.clientY });
  };

  const handleCopy = () => {
    copySelectedCuts();
    setContextMenu(null);
  };

  const handlePaste = () => {
    // Paste after the current cut's position
    pasteCuts(sceneId, index + 1);
    setContextMenu(null);
  };

  const handleDelete = () => {
    const cutIds = getSelectedCutIds();
    // Delete all selected cuts
    for (const cutId of cutIds) {
      // Find which scene contains this cut
      for (const scene of scenes) {
        if (scene.cuts.some(c => c.id === cutId)) {
          removeCut(scene.id, cutId);
          break;
        }
      }
    }
    setContextMenu(null);
  };

  const handleMoveToScene = (targetSceneId: string) => {
    const cutIds = getSelectedCutIds();
    // Get target scene's cut count for append position
    const targetScene = scenes.find(s => s.id === targetSceneId);
    const toIndex = targetScene?.cuts.length || 0;
    moveCutsToScene(cutIds, targetSceneId, toIndex);
    setContextMenu(null);
  };

  const handleCreateGroup = () => {
    const selectedCuts = getSelectedCuts();
    // Check all cuts are in the same scene
    const allSameScene = selectedCuts.every(({ scene }) => scene.id === sceneId);
    if (!allSameScene || selectedCuts.length < 2) {
      setContextMenu(null);
      return;
    }

    const cutIds = selectedCuts.map(({ cut: c }) => c.id);
    createGroup(sceneId, cutIds, `Group ${Date.now()}`);
    setContextMenu(null);
  };

  const handleRemoveFromGroup = () => {
    if (!cutGroup) {
      setContextMenu(null);
      return;
    }

    removeCutFromGroup(sceneId, cutGroup.id, cut.id);
    setContextMenu(null);
  };

  const handleFinalizeClip = async (reverseOutput: boolean) => {
    if (!cut.isClip || cut.inPoint === undefined || cut.outPoint === undefined || !asset?.path) {
      setContextMenu(null);
      return;
    }

    if (!window.electronAPI) {
      alert('electronAPI not available. Please restart the app.');
      setContextMenu(null);
      return;
    }

    // Check if vault path is set
    if (!vaultPath) {
      alert('Vault path not set. Please set up a vault first.');
      setContextMenu(null);
      return;
    }

    // Check if the API methods exist
    if (typeof window.electronAPI.finalizeClip !== 'function' ||
        typeof window.electronAPI.ensureAssetsFolder !== 'function') {
      alert('Finalize Clip feature requires app restart after update.\nPlease restart the Electron app.');
      setContextMenu(null);
      return;
    }

    if (reverseOutput) {
      const proceed = confirm('Reverse export is memory intensive and may temporarily pause the app.\nContinue?');
      if (!proceed) {
        setContextMenu(null);
        return;
      }
    }

    try {
      // Ensure assets folder exists
      const assetsFolder = await window.electronAPI.ensureAssetsFolder(vaultPath);
      if (!assetsFolder) {
        alert('Failed to access assets folder in vault.');
        setContextMenu(null);
        return;
      }

      const clipStart = Math.min(cut.inPoint, cut.outPoint);
      const clipEnd = Math.max(cut.inPoint, cut.outPoint);
      const clipDuration = Math.abs(cut.outPoint - cut.inPoint);

      // Generate unique filename: {original_name}_clip_{timestamp}.mp4
      const baseName = asset.name.replace(/\.[^/.]+$/, ''); // Remove extension
      const timestamp = Date.now();
      const clipFileName = reverseOutput
        ? `${baseName}_clip_reverse_${timestamp}.mp4`
        : `${baseName}_clip_${timestamp}.mp4`;
      const outputPath = `${assetsFolder}/${clipFileName}`.replace(/\\/g, '/');

      // Finalize the clip (auto-save to vault assets)
      const result = await window.electronAPI.finalizeClip({
        sourcePath: asset.path,
        outputPath,
        inPoint: clipStart,
        outPoint: clipEnd,
        reverse: reverseOutput,
      });

      if (result.success) {
        const newCutId = await createCutFromImport(sceneId, {
          assetId: uuidv4(),
          name: clipFileName,
          sourcePath: outputPath,
          type: 'video',
          fileSize: result.fileSize,
          preferredDuration: clipDuration,
        }, index + 1, vaultPath);

        const latestGroup = getCutGroup(sceneId, cut.id);
        if (latestGroup && !latestGroup.cutIds.includes(newCutId)) {
          const insertAt = Math.max(0, latestGroup.cutIds.indexOf(cut.id) + 1);
          const nextOrder = [...latestGroup.cutIds];
          nextOrder.splice(insertAt, 0, newCutId);
          updateGroupCutOrder(sceneId, latestGroup.id, nextOrder);
        }

        alert(`Clip exported and added to timeline!\n\nFile: ${clipFileName}\nSize: ${(result.fileSize! / 1024 / 1024).toFixed(2)} MB`);
      } else {
        alert(`Failed to export clip: ${result.error}`);
      }
    } catch (error) {
      alert(`Error finalizing clip: ${error}`);
    }

    setContextMenu(null);
  };

  const handleReverseClip = () => handleFinalizeClip(true);
  const handleFinalizeClipNormal = () => handleFinalizeClip(false);

  // If loading, show loading card
  if (cut.isLoading) {
    return (
      <div
        ref={setNodeRef}
        style={style}
        {...attributes}
        {...listeners}
        className={`cut-card loading ${isDragging ? 'dragging' : ''}`}
      >
        <div className="cut-thumbnail-container">
          <div className="cut-thumbnail placeholder loading-placeholder">
            {showLoadingSpinner && (
              <Loader2 size={24} className="loading-spinner" />
            )}
          </div>
          <div className="cut-loading-name" title={cut.loadingName}>
            {cut.loadingName}
          </div>
        </div>
      </div>
    );
  }

  return (
    <>
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className={`cut-card ${isSelected ? 'selected' : ''} ${isMultiSelected ? 'multi-selected' : ''} ${isDragging ? 'dragging' : ''} ${isLipSync ? 'lipsync' : ''}`}
      onClick={handleClick}
      onDoubleClick={handleDoubleClick}
      onContextMenu={handleContextMenu}
    >
      <div className="cut-thumbnail-container">
        {thumbnail ? (
          <img
            src={thumbnail}
            alt={asset?.name || 'Cut'}
            className="cut-thumbnail"
          />
        ) : (
          <div className="cut-thumbnail placeholder">
            {isLipSync ? (
              <Mic size={24} className="placeholder-icon" />
            ) : isVideo ? (
              <Film size={24} className="placeholder-icon" />
            ) : (
              <Image size={24} className="placeholder-icon" />
            )}
          </div>
        )}

        <div className={`cut-badge ${isLipSync ? 'lipsync' : ''}`} style={isLipSync ? undefined : { backgroundColor: getBadgeColor() }}>
          {isLipSync ? 'S:LIP' : isVideo ? 'S:VID' : 'S:IMG'}
        </div>

        {/* Lip sync indicator */}
        {isLipSync && (
          <div className="lipsync-indicator" title="Lip Sync Cut">
            <Mic size={12} />
          </div>
        )}

        {/* Lip sync frame count */}
        {isLipSync && cut.lipSyncFrameCount && (
          <div className="lipsync-frame-count">
            <Image size={10} />
            <span>{cut.lipSyncFrameCount}</span>
          </div>
        )}

        {/* Clip indicator for trimmed videos */}
        {cut.isClip && !isLipSync && (
          <div className="clip-indicator" title={`Clip: ${cut.inPoint?.toFixed(1)}s - ${cut.outPoint?.toFixed(1)}s`}>
            <Scissors size={12} />
          </div>
        )}

        {/* Attached audio indicator */}
        {hasAttachedAudio && !isLipSync && !cut.isClip && (
          <div className="audio-attached-indicator" title="Audio Attached">
            <Music size={12} />
          </div>
        )}

        <div className="cut-duration">
          <Clock size={10} />
          <span>{cut.displayTime.toFixed(1)}s</span>
        </div>
      </div>
    </div>

    {contextMenu && (
      <CutContextMenu
        x={contextMenu.x}
        y={contextMenu.y}
        isMultiSelect={isMultiSelected}
        selectedCount={selectedCutIds.size}
        scenes={scenes}
        currentSceneId={sceneId}
        canPaste={canPaste()}
        isClip={!!cut.isClip}
        isInGroup={isInGroup}
        onClose={() => setContextMenu(null)}
        onCopy={handleCopy}
        onPaste={handlePaste}
        onDelete={handleDelete}
        onMoveToScene={handleMoveToScene}
        onFinalizeClip={handleFinalizeClipNormal}
        onReverseClip={handleReverseClip}
        onCreateGroup={isMultiSelected ? handleCreateGroup : undefined}
        onRemoveFromGroup={isInGroup ? handleRemoveFromGroup : undefined}
      />
    )}
    </>
  );
}
